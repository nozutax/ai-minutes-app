<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI議事録アプリ (Gemini)</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        h1 { text-align: center; color: #4285f4; }
        .section { background: #f9f9f9; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd; }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        input[type="password"] { width: 100%; padding: 10px; margin-bottom: 10px; box-sizing: border-box; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; margin-right: 10px; margin-bottom: 10px; }
        
        .btn-blue { background-color: #4285f4; }
        .btn-red { background-color: #ea4335; }
        .btn-green { background-color: #34a853; }
        .btn-orange { background-color: #f6851b; }
        
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        textarea { width: 100%; height: 200px; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; margin-top: 10px; }
        #status { font-weight: bold; color: #4285f4; margin-top: 10px; }
        .error { color: #ea4335; }
        .note { font-size: 0.9em; color: #666; }
        .checkbox-label { font-weight: normal; font-size: 0.95em; cursor: pointer; display: flex; align-items: center; margin-top: 5px; }
        .checkbox-label input { width: auto; margin-right: 8px; margin-bottom: 0; }
        
        .prompt-area { height: 80px; margin-bottom: 5px; }
        .compression-options { margin-bottom: 15px; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 5px; }
        .radio-label { margin-right: 15px; font-weight: normal; cursor: pointer; }
        .radio-label input { margin-right: 5px; }
    </style>
</head>
<body>

    <h1>AI議事録アプリ (Gemini)</h1>

    <!-- APIキー入力 -->
    <div class="section">
        <label>Gemini API Keyを入力してください:</label>
        <input type="password" id="apiKey" placeholder="AIza..." value="">
        
        <label class="checkbox-label">
            <input type="checkbox" id="saveKeyCheckbox"> 次回から自動入力する
        </label>
        <p class="note" style="margin-top:10px;">※キーはブラウザ内でのみ使用・保存され、外部サーバーには送信されません。</p>
    </div>

    <!-- 1. 録音 -->
    <div class="section">
        <h2>1. 録音</h2>
        
        <label>文字起こしへの追加指示（プロンプト）:</label>
        <textarea id="customPrompt" class="prompt-area" placeholder="例：専門用語の「〇〇」はカタカナ表記にしてください。話者が複数の場合は「Aさん」「Bさん」と分けてください。"></textarea>
        <label class="checkbox-label">
            <input type="checkbox" id="savePromptCheckbox"> このプロンプトを次回も使用する
        </label>
        <br>

        <button id="startBtn" class="btn-blue" onclick="startRecording()">録音開始</button>
        <button id="stopBtn" class="btn-red" onclick="stopRecording()" disabled>停止</button>
        <p id="status">待機中...</p>
        <!-- ▼▼▼ 修正箇所：文言を削除 ▼▼▼ -->
        <p class="note">※約3分ごとに自動で区切って文字起こしを行います。</p>
        <!-- ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ -->
    </div>

    <!-- 2. 確認 -->
    <div class="section">
        <h2>2. 文字起こし確認・修正</h2>
        <p class="note">録音中もここに順次テキストが追加されていきます。</p>
        <textarea id="transcriptionText" placeholder="ここに文字起こし結果が順次表示されます..."></textarea>
        <br><br>

        <div class="compression-options">
            <label style="margin-bottom:8px;">議事録の圧縮率（要約レベル）:</label>
            <label class="radio-label">
                <input type="radio" name="compression" value="high"> 高 (約95%カット)
            </label>
            <label class="radio-label">
                <input type="radio" name="compression" value="medium" checked> 中 (約70%カット)
            </label>
            <label class="radio-label">
                <input type="radio" name="compression" value="low"> 低 (約30%カット)
            </label>
        </div>

        <button id="summarizeBtn" class="btn-green" onclick="generateMinutes()" disabled>この内容で議事録を作成</button>
        <button id="dlTransBtn" class="btn-orange" onclick="downloadText('transcriptionText', 'transcription')" disabled>文字起こしをダウンロード</button>
    </div>

    <!-- 3. 結果 -->
    <div class="section">
        <h2>3. 議事録出力</h2>
        <textarea id="minutesText" placeholder="ここに議事録が出力されます..." readonly></textarea>
        <br><br>
        <button id="dlMinutesBtn" class="btn-orange" onclick="downloadText('minutesText', 'minutes')" disabled>議事録をダウンロード</button>
    </div>

    <script>
        // 設定：3分 (180000ms)
        const CHUNK_INTERVAL_MS = 180000; 
        const MODEL_NAME = "gemini-2.5-pro";

        let activeRecorder = null; // 現在稼働中のレコーダー
        let stream; 
        let isRecording = false; 
        let chunkTimer = null;   
        let chunkCount = 0;      

        window.addEventListener('load', () => {
            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
                document.getElementById('saveKeyCheckbox').checked = true;
            }

            const savedPrompt = localStorage.getItem('gemini_custom_prompt');
            if (savedPrompt) {
                document.getElementById('customPrompt').value = savedPrompt;
                document.getElementById('savePromptCheckbox').checked = true;
            }
        });

        // 録音開始
        async function startRecording() {
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert("先にGemini API Keyを入力してください");
                return;
            }

            // 保存処理
            const shouldSaveKey = document.getElementById('saveKeyCheckbox').checked;
            localStorage.setItem('gemini_api_key', shouldSaveKey ? apiKey : "");
            if (!shouldSaveKey) localStorage.removeItem('gemini_api_key');

            const customPrompt = document.getElementById('customPrompt').value;
            const shouldSavePrompt = document.getElementById('savePromptCheckbox').checked;
            if (shouldSavePrompt) localStorage.setItem('gemini_custom_prompt', customPrompt);
            else localStorage.removeItem('gemini_custom_prompt');

            try {
                // UIリセット
                document.getElementById('transcriptionText').value = "";
                document.getElementById('minutesText').value = "";
                document.getElementById('dlTransBtn').disabled = true;
                document.getElementById('dlMinutesBtn').disabled = true;

                // マイク取得
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                isRecording = true;
                chunkCount = 0;
                
                toggleButtons(true);
                updateStatus("録音開始...", false);

                // 録音ループ開始
                rotateRecorder();

            } catch (err) {
                alert("マイクの使用が許可されていません。");
                console.error(err);
                updateStatus("エラー: マイクにアクセスできませんでした", true);
            }
        }

        // レコーダーを切り替える関数
        function rotateRecorder() {
            if (!isRecording) return;

            chunkCount++;
            
            // 1. 新しいレコーダーを作成
            let localChunks = [];
            const newRecorder = new MediaRecorder(stream);
            
            newRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    localChunks.push(event.data);
                }
            };

            const currentCountForThisRecorder = chunkCount;
            
            newRecorder.onstop = () => {
                const audioBlob = new Blob(localChunks, { type: 'audio/webm' });
                processChunkWithGemini(audioBlob, currentCountForThisRecorder);
            };

            // 2. 新しいレコーダーを開始
            newRecorder.start();
            console.log(`Recorder #${currentCountForThisRecorder} started.`);

            // 3. 古いレコーダーを停止
            if (activeRecorder && activeRecorder.state !== "inactive") {
                activeRecorder.stop();
            }

            // 4. 更新
            activeRecorder = newRecorder;

            // 5. 次のタイマー
            chunkTimer = setTimeout(() => {
                if (isRecording) {
                    rotateRecorder();
                }
            }, CHUNK_INTERVAL_MS);
        }

        // 停止ボタン処理
        function stopRecording() {
            isRecording = false;
            
            if (chunkTimer) clearTimeout(chunkTimer);

            if (activeRecorder && activeRecorder.state !== "inactive") {
                activeRecorder.stop();
            }

            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            updateStatus("録音終了。処理を待機中...", true);
            toggleButtons(false);
        }

        // Gemini APIへチャンクを送信
        async function processChunkWithGemini(audioBlob, currentChunkIndex) {
            const apiKey = document.getElementById('apiKey').value;
            const customPromptText = document.getElementById('customPrompt').value;

            updateStatus(`データ #${currentChunkIndex} を解析中...`, true);

            try {
                const base64Audio = await blobToBase64(audioBlob);
                const cleanBase64 = base64Audio.split(',')[1];
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

                const payload = {
                    contents: [{
                        parts: [
                            { text: `あなたは熟練した文字起こし担当者です。
添付の音声データは、長い会議を3分ごとに区切ったうちの「パート${currentChunkIndex}」です。

【重要：音切れへの対応】
・ファイルが区切られているため、冒頭や末尾で単語が途切れている場合があります。
・そのような場合でも、**聞こえた音を勝手に省略せず、そのまま書き起こしてください**。文脈で補完できる場合は補完しても構いません。

【ユーザーからの追加指示】
${customPromptText}

【極めて重要な指示】
・出力には、挨拶、返事、説明書きは一切含めないでください。
・音声の内容のみを出力してください。
・「あー」「えっと」などの言い淀みも含めて文字にしてください。
・話者が切り替わるタイミングは改行してください。` },
                            {
                                inline_data: {
                                    mime_type: "audio/webm",
                                    data: cleanBase64
                                }
                            }
                        ]
                    }],
                    safetySettings: [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ]
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts) {
                     let transcript = data.candidates[0].content.parts[0].text;
                     transcript = transcript.trim();
                     
                     const textArea = document.getElementById('transcriptionText');
                     if (textArea.value) {
                         textArea.value += "\n" + transcript;
                     } else {
                         textArea.value = transcript;
                     }
                     textArea.scrollTop = textArea.scrollHeight;

                     document.getElementById('summarizeBtn').disabled = false;
                     document.getElementById('dlTransBtn').disabled = false;
                     
                     if (!isRecording) {
                         updateStatus("すべての文字起こしが完了しました。", false);
                     } else {
                         updateStatus(`データ #${currentChunkIndex} の解析完了。録音継続中...`, false);
                     }

                } else {
                     console.warn(`Chunk #${currentChunkIndex} empty response.`);
                }

            } catch (error) {
                console.error(`Error processing chunk #${currentChunkIndex}:`, error);
                const textArea = document.getElementById('transcriptionText');
                textArea.value += `\n[エラー: データ #${currentChunkIndex} の処理に失敗しました]\n`;
            }
        }

        // 議事録作成
        async function generateMinutes() {
            const text = document.getElementById('transcriptionText').value;
            const apiKey = document.getElementById('apiKey').value;
            
            const compressionElements = document.getElementsByName('compression');
            let compressionRate = 'medium';
            for (const el of compressionElements) {
                if (el.checked) {
                    compressionRate = el.value;
                    break;
                }
            }

            if (!text) return;

            updateStatus("AIが議事録を作成中...", true);
            document.getElementById('summarizeBtn').disabled = true;

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

            let compressionInstruction = "";
            if (compressionRate === "high") {
                compressionInstruction = `
                【重要：圧縮率「高」】
                ・元の文章量から約95%を削減し、極めて簡潔にまとめてください。
                ・詳細な経緯は省き、最終的な「決定事項」と「重要な結論」のみを抽出してください。`;
            } else if (compressionRate === "medium") {
                compressionInstruction = `
                【重要：圧縮率「中」】
                ・元の文章量から約70%を削減し、標準的な議事録の長さにしてください。
                ・議論の流れが分かる程度に要約してください。`;
            } else {
                compressionInstruction = `
                【重要：圧縮率「低」】
                ・元の文章量から約30%のみを削減し、詳細な議事録を作成してください。
                ・不要な言葉や繰り返しのみを削除してください。`;
            }

            const prompt = `
            以下の会議の文字起こしテキスト（分割して認識されたものの結合）をもとに、整合性の取れた簡潔な議事録を作成してください。
            
            ${compressionInstruction}

            マークダウン形式を使わず、プレーンテキストで見やすく出力してください。
            挨拶や返事は不要です。

            【形式】
            ・議題
            ・決定事項
            ・ネクストアクション

            【テキスト】
            ${text}
            `;

            try {
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    safetySettings: [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ]
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.error) throw new Error(data.error.message);

                if (data.candidates && data.candidates[0].content) {
                    const summary = data.candidates[0].content.parts[0].text;
                    document.getElementById('minutesText').value = summary;
                    document.getElementById('dlMinutesBtn').disabled = false;
                    updateStatus("議事録作成完了！", false);
                } else {
                    throw new Error("議事録の生成に失敗しました（応答が空）。");
                }

            } catch (error) {
                updateStatus(`エラー: ${error.message}`, true);
            } finally {
                document.getElementById('summarizeBtn').disabled = false;
            }
        }

        // ユーティリティ
        function downloadText(elementId, filePrefix) {
            const text = document.getElementById(elementId).value;
            if (!text) { alert("ダウンロードする内容がありません。"); return; }
            const now = new Date();
            const timestamp = now.toISOString().replace(/[-:T.]/g, "").slice(0, 14);
            const filename = `${filePrefix}_${timestamp}.txt`;
            const blob = new Blob([text], { type: "text/plain" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function updateStatus(msg, isProcessing) {
            const el = document.getElementById('status');
            el.innerText = msg;
            el.className = isProcessing ? '' : (msg.includes('エラー') ? 'error' : '');
            el.style.color = isProcessing ? '#4285f4' : (msg.includes('エラー') ? '#ea4335' : '#333');
        }

        function toggleButtons(isRecording) {
            document.getElementById('startBtn').disabled = isRecording;
            document.getElementById('stopBtn').disabled = !isRecording;
        }
    </script>
</body>
</html>
