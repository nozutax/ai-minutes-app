<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI議事録アプリ (Gemini)</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        h1 { text-align: center; color: #4285f4; }
        .section { background: #f9f9f9; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd; }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        input[type="password"] { width: 100%; padding: 10px; margin-bottom: 10px; box-sizing: border-box; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; margin-right: 10px; margin-bottom: 10px; }
        
        .btn-blue { background-color: #4285f4; }
        .btn-red { background-color: #ea4335; }
        .btn-green { background-color: #34a853; }
        .btn-orange { background-color: #f6851b; }
        
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        textarea { width: 100%; height: 200px; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; margin-top: 10px; }
        #status { font-weight: bold; color: #4285f4; margin-top: 10px; }
        .error { color: #ea4335; }
        .note { font-size: 0.9em; color: #666; }
        .checkbox-label { font-weight: normal; font-size: 0.95em; cursor: pointer; display: flex; align-items: center; margin-top: 5px; }
        .checkbox-label input { width: auto; margin-right: 8px; margin-bottom: 0; }
        
        .prompt-area { height: 80px; margin-bottom: 5px; }
        .compression-options { margin-bottom: 15px; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 5px; }
        .radio-label { margin-right: 15px; font-weight: normal; cursor: pointer; }
        .radio-label input { margin-right: 5px; }
    </style>
</head>
<body>

    <h1>AI議事録アプリ (Gemini)</h1>

    <!-- APIキー入力 -->
    <div class="section">
        <label>Gemini API Keyを入力してください:</label>
        <input type="password" id="apiKey" placeholder="AIza..." value="">
        
        <label class="checkbox-label">
            <input type="checkbox" id="saveKeyCheckbox"> 次回から自動入力する
        </label>
        <p class="note" style="margin-top:10px;">※キーはブラウザ内でのみ使用・保存され、外部サーバーには送信されません。</p>
    </div>

    <!-- 1. 録音 -->
    <div class="section">
        <h2>1. 録音</h2>
        
        <label>文字起こしへの追加指示（プロンプト）:</label>
        <textarea id="customPrompt" class="prompt-area" placeholder="例：専門用語の「〇〇」はカタカナ表記にしてください。話者が複数の場合は「Aさん」「Bさん」と分けてください。"></textarea>
        <label class="checkbox-label">
            <input type="checkbox" id="savePromptCheckbox"> このプロンプトを次回も使用する
        </label>
        <br>

        <button id="startBtn" class="btn-blue" onclick="startRecording()">録音開始</button>
        <button id="stopBtn" class="btn-red" onclick="stopRecording()" disabled>停止</button>
        <p id="status">待機中...</p>
        <p class="note">※約1分ごとに自動で区切って文字起こしを行います。</p>
    </div>

    <!-- 2. 確認 -->
    <div class="section">
        <h2>2. 文字起こし確認・修正</h2>
        <p class="note">録音中もここに順次テキストが追加されていきます。</p>
        <textarea id="transcriptionText" placeholder="ここに文字起こし結果が順次表示されます..."></textarea>
        <br><br>

        <div class="compression-options">
            <label style="margin-bottom:8px;">議事録の圧縮率（要約レベル）:</label>
            <label class="radio-label">
                <input type="radio" name="compression" value="high"> 高 (約95%カット)
            </label>
            <label class="radio-label">
                <input type="radio" name="compression" value="medium" checked> 中 (約70%カット)
            </label>
            <label class="radio-label">
                <input type="radio" name="compression" value="low"> 低 (約30%カット)
            </label>
        </div>

        <button id="summarizeBtn" class="btn-green" onclick="generateMinutes()" disabled>この内容で議事録を作成</button>
        <button id="dlTransBtn" class="btn-orange" onclick="downloadText('transcriptionText', 'transcription')" disabled>文字起こしをダウンロード</button>
    </div>

    <!-- 3. 結果 -->
    <div class="section">
        <h2>3. 議事録出力</h2>
        <textarea id="minutesText" placeholder="ここに議事録が出力されます..." readonly></textarea>
        <br><br>
        <button id="dlMinutesBtn" class="btn-orange" onclick="downloadText('minutesText', 'minutes')" disabled>議事録をダウンロード</button>
    </div>

    <script>
        // 設定：何ミリ秒ごとにファイルを区切るか（ここでは60秒＝60000ms）
        const CHUNK_INTERVAL_MS = 60000; 
        const MODEL_NAME = "gemini-2.5-pro";

        let mediaRecorder;
        let stream; 
        let isRecording = false; // 録音状態フラグ
        let chunkTimer = null;   // タイマー管理
        let chunkCount = 0;      // 今何個目のファイルか

        window.addEventListener('load', () => {
            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
                document.getElementById('saveKeyCheckbox').checked = true;
            }

            const savedPrompt = localStorage.getItem('gemini_custom_prompt');
            if (savedPrompt) {
                document.getElementById('customPrompt').value = savedPrompt;
                document.getElementById('savePromptCheckbox').checked = true;
            }
        });

        // 録音開始（最初のセットアップ）
        async function startRecording() {
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert("先にGemini API Keyを入力してください");
                return;
            }

            // 保存処理
            const shouldSaveKey = document.getElementById('saveKeyCheckbox').checked;
            localStorage.setItem('gemini_api_key', shouldSaveKey ? apiKey : "");
            if (!shouldSaveKey) localStorage.removeItem('gemini_api_key');

            const customPrompt = document.getElementById('customPrompt').value;
            const shouldSavePrompt = document.getElementById('savePromptCheckbox').checked;
            if (shouldSavePrompt) localStorage.setItem('gemini_custom_prompt', customPrompt);
            else localStorage.removeItem('gemini_custom_prompt');

            try {
                // UIリセット
                document.getElementById('transcriptionText').value = "";
                document.getElementById('minutesText').value = "";
                document.getElementById('dlTransBtn').disabled = true;
                document.getElementById('dlMinutesBtn').disabled = true;

                // マイク取得（これは録音中ずっと維持する）
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                isRecording = true;
                chunkCount = 0;
                
                toggleButtons(true);
                updateStatus("録音開始... (1分ごとに文字起こしします)", false);

                // 最初の録音セグメントを開始
                startNextChunk();

            } catch (err) {
                alert("マイクの使用が許可されていません。");
                console.error(err);
                updateStatus("エラー: マイクにアクセスできませんでした", true);
            }
        }

        // 録音の1セグメントを開始する関数
        function startNextChunk() {
            if (!isRecording) return;

            chunkCount++;
            let localChunks = [];

            // 新しいレコーダーを作成（ストリームは使い回す）
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    localChunks.push(event.data);
                }
            };

            // このセグメントの録音が止まったら、すぐにGeminiへ送信
            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(localChunks, { type: 'audio/webm' });
                processChunkWithGemini(audioBlob, chunkCount);
            };

            mediaRecorder.start();
            console.log(`Chunk #${chunkCount} started.`);

            // 指定時間（1分）後にこのレコーダーを止めるタイマーをセット
            chunkTimer = setTimeout(() => {
                if (isRecording) {
                    // 録音継続中なら、今のレコーダーを止めて次を開始
                    stopCurrentRecorderAndNext();
                }
            }, CHUNK_INTERVAL_MS);
        }

        // 現在のレコーダーを止めて、次を即座に開始する（ギャップを最小にする）
        function stopCurrentRecorderAndNext() {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop(); // これが onstop を発火させ、Gemini送信へ
            }
            // 即座に次を開始
            if (isRecording) {
                startNextChunk();
            }
        }

        // ユーザーが停止ボタンを押したとき
        function stopRecording() {
            isRecording = false;
            
            // タイマー解除
            if (chunkTimer) clearTimeout(chunkTimer);

            // 現在動いている最後のレコーダーを停止（最後の送信が行われる）
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }

            // マイク自体の停止（赤いアイコンを消す）
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            updateStatus("録音終了。最後のデータの文字起こしを待機中...", true);
            toggleButtons(false);
        }

        // Gemini APIへチャンクを送信する
        async function processChunkWithGemini(audioBlob, currentChunkIndex) {
            const apiKey = document.getElementById('apiKey').value;
            const customPromptText = document.getElementById('customPrompt').value;

            updateStatus(`データ #${currentChunkIndex} を解析中...`, true);

            try {
                const base64Audio = await blobToBase64(audioBlob);
                const cleanBase64 = base64Audio.split(',')[1];
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

                const payload = {
                    contents: [{
                        parts: [
                            { text: `あなたは熟練した文字起こし担当者です。
添付の音声データは会議の「途中の一部（約1分間）」です。
前後の文脈は気にせず、聞こえた内容を一言一句省略せずに（逐語起こしで）書き出してください。

【ユーザーからの追加指示】
${customPromptText}

【極めて重要な指示】
・出力には、挨拶、返事、説明書きは一切含めないでください。
・音声の内容のみを出力してください。

【制約事項】
・「あー」「えっと」などの言い淀みも含めて文字にしてください。
・話者が切り替わるタイミングは改行してください。` },
                            {
                                inline_data: {
                                    mime_type: "audio/webm",
                                    data: cleanBase64
                                }
                            }
                        ]
                    }],
                    safetySettings: [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ]
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts) {
                     let transcript = data.candidates[0].content.parts[0].text;
                     transcript = transcript.trim();
                     
                     // ▼▼▼ 追記処理 ▼▼▼
                     const textArea = document.getElementById('transcriptionText');
                     // 前のテキストがあれば改行を入れて追記
                     if (textArea.value) {
                         textArea.value += "\n\n" + transcript;
                     } else {
                         textArea.value = transcript;
                     }
                     // 一番下までスクロール
                     textArea.scrollTop = textArea.scrollHeight;

                     document.getElementById('summarizeBtn').disabled = false;
                     document.getElementById('dlTransBtn').disabled = false;
                     
                     // 録音が終わっていて、これが最後の処理だった場合
                     if (!isRecording) {
                         updateStatus("すべての文字起こしが完了しました。", false);
                     } else {
                         updateStatus(`データ #${currentChunkIndex} の解析完了。録音継続中...`, false);
                     }

                } else {
                     console.warn(`Chunk #${currentChunkIndex} empty response.`);
                }

            } catch (error) {
                console.error(`Error processing chunk #${currentChunkIndex}:`, error);
                const textArea = document.getElementById('transcriptionText');
                textArea.value += `\n\n[エラー: データ #${currentChunkIndex} の処理に失敗しました]`;
            }
        }

        // 議事録作成
        async function generateMinutes() {
            const text = document.getElementById('transcriptionText').value;
            const apiKey = document.getElementById('apiKey').value;
            
            // 圧縮率取得
            const compressionElements = document.getElementsByName('compression');
            let compressionRate = 'medium';
            for (const el of compressionElements) {
                if (el.checked) {
                    compressionRate = el.value;
                    break;
                }
            }

            if (!text) return;

            updateStatus("AIが議事録を作成中...", true);
            document.getElementById('summarizeBtn').disabled = true;

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

            let compressionInstruction = "";
            if (compressionRate === "high") {
                compressionInstruction = `
                【重要：圧縮率「高」】
                ・元の文章量から約95%を削減し、極めて簡潔にまとめてください。
