<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI議事録アプリ (Gemini)</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        h1 { text-align: center; color: #4285f4; }
        .section { background: #f9f9f9; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd; }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        input[type="password"] { width: 100%; padding: 10px; margin-bottom: 10px; box-sizing: border-box; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; color: white; margin-right: 10px; margin-bottom: 10px; }
        
        /* ボタンの色定義 */
        .btn-blue { background-color: #4285f4; }
        .btn-red { background-color: #ea4335; }
        .btn-green { background-color: #34a853; }
        .btn-orange { background-color: #f6851b; }
        
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        textarea { width: 100%; height: 150px; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; margin-top: 10px; }
        #status { font-weight: bold; color: #4285f4; margin-top: 10px; }
        .error { color: #ea4335; }
        .note { font-size: 0.9em; color: #666; }
        .checkbox-label { font-weight: normal; font-size: 0.95em; cursor: pointer; display: flex; align-items: center; }
        .checkbox-label input { width: auto; margin-right: 8px; margin-bottom: 0; }
    </style>
</head>
<body>

    <h1>AI議事録アプリ (Gemini)</h1>

    <!-- APIキー入力 -->
    <div class="section">
        <label>Gemini API Keyを入力してください:</label>
        <input type="password" id="apiKey" placeholder="AIza..." value="">
        
        <label class="checkbox-label">
            <input type="checkbox" id="saveKeyCheckbox"> 次回から自動入力する
        </label>
        
        <p class="note" style="margin-top:10px;">※キーはブラウザ内でのみ使用・保存され、外部サーバーには送信されません。</p>
    </div>

    <!-- 1. 録音 -->
    <div class="section">
        <h2>1. 録音</h2>
        <button id="startBtn" class="btn-blue" onclick="startRecording()">録音開始</button>
        <button id="stopBtn" class="btn-red" onclick="stopRecording()" disabled>停止＆文字起こし</button>
        <p id="status">待機中...</p>
    </div>

    <!-- 2. 確認 -->
    <div class="section">
        <h2>2. 文字起こし確認・修正</h2>
        <textarea id="transcriptionText" placeholder="ここに文字起こし結果が表示されます..."></textarea>
        <br><br>
        <button id="summarizeBtn" class="btn-green" onclick="generateMinutes()" disabled>この内容で議事録を作成</button>
        <button id="dlTransBtn" class="btn-orange" onclick="downloadText('transcriptionText', 'transcription')" disabled>文字起こしをダウンロード</button>
    </div>

    <!-- 3. 結果 -->
    <div class="section">
        <h2>3. 議事録出力</h2>
        <textarea id="minutesText" placeholder="ここに議事録が出力されます..." readonly></textarea>
        <br><br>
        <button id="dlMinutesBtn" class="btn-orange" onclick="downloadText('minutesText', 'minutes')" disabled>議事録をダウンロード</button>
    </div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let stream; 
        const MODEL_NAME = "gemini-2.5-pro";

        // ページ読み込み時に保存されたキーを復元
        window.addEventListener('load', () => {
            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
                document.getElementById('saveKeyCheckbox').checked = true;
            }
        });

        // 録音開始
        async function startRecording() {
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert("先にGemini API Keyを入力してください");
                return;
            }

            // キー保存処理
            const shouldSave = document.getElementById('saveKeyCheckbox').checked;
            if (shouldSave) {
                localStorage.setItem('gemini_api_key', apiKey);
            } else {
                localStorage.removeItem('gemini_api_key');
            }

            try {
                // UIリセット
                document.getElementById('transcriptionText').value = "";
                document.getElementById('minutesText').value = "";
                document.getElementById('dlTransBtn').disabled = true;
                document.getElementById('dlMinutesBtn').disabled = true;

                audioChunks = [];

                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = processAudioWithGemini;

                mediaRecorder.start();
                updateStatus("録音中...", false);
                toggleButtons(true);
            } catch (err) {
                alert("マイクの使用が許可されていません。ブラウザの設定を確認してください。");
                console.error(err);
                updateStatus("エラー: マイクにアクセスできませんでした", true);
            }
        }

        // 録音停止
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }

            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            updateStatus("音声データを処理中...", true);
            toggleButtons(false);
        }

        // Geminiで音声文字起こし
        async function processAudioWithGemini() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const apiKey = document.getElementById('apiKey').value;

            updateStatus("Gemini に送信中...（解析中）", true);

            try {
                const base64Audio = await blobToBase64(audioBlob);
                const cleanBase64 = base64Audio.split(',')[1];

                const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

                const payload = {
                    contents: [{
                        parts: [
                            // ▼▼▼ プロンプト修正: 余計な返事を禁止 ▼▼▼
                            { text: `あなたは熟練した文字起こし担当者です。
添付の音声データの内容を、一言一句省略せずに（逐語起こしで）書き出してください。

【極めて重要な指示】
・出力には、あなた（AI）からの挨拶、了解の返事、説明書き（「以下に記載します」等）は一切含めないでください。
・音声の内容のみをいきなり出力してください。

【制約事項】
・「あー」「えっと」などの言い淀みや、言い間違いも含めて、聞こえた通りにすべて文字にしてください。
・話者の感情や調子（笑いながら、怒って、など）が分かる場合は、（笑）や（怒）のように注釈を入れてください。
・話者が切り替わるタイミングは明確に段落を分けてください。` },
                            // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
                            {
                                inline_data: {
                                    mime_type: "audio/webm",
                                    data: cleanBase64
                                }
                            }
                        ]
                    }]
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                if (data.candidates && data.candidates[0].content) {
                     let transcript = data.candidates[0].content.parts[0].text;
                     
                     // 念のためのトリミング（前後の改行等を削除）
                     transcript = transcript.trim();
                     
                     document.getElementById('transcriptionText').value = transcript;
                     
                     document.getElementById('summarizeBtn').disabled = false;
                     document.getElementById('dlTransBtn').disabled = false;
                     updateStatus("文字起こし完了。", false);
                } else {
                     throw new Error("Geminiからの応答が空でした。録音が短すぎるか、音声が認識されませんでした。");
                }

            } catch (error) {
                updateStatus(`エラー: ${error.message}`, true);
                console.error(error);
            }
        }

        // Geminiで議事録作成
        async function generateMinutes() {
            const text = document.getElementById('transcriptionText').value;
            const apiKey = document.getElementById('apiKey').value;

            if (!text) return;

            updateStatus("AIが議事録を作成中...", true);
            document.getElementById('summarizeBtn').disabled = true;

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

            const prompt = `
            以下の会議の文字起こしテキストをもとに、簡潔な議事録を作成してください。
            マークダウン形式を使わず、プレーンテキストで見やすく出力してください。
            挨拶や返事は不要です。

            【形式】
            ・議題
            ・決定事項
            ・ネクストアクション

            【テキスト】
            ${text}
            `;

            try {
                const payload = {
                    contents: [{
                        parts: [{ text: prompt }]
                    }]
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                const summary = data.candidates[0].content.parts[0].text;
                document.getElementById('minutesText').value = summary;
                document.getElementById('dlMinutesBtn').disabled = false;

                updateStatus("議事録作成完了！", false);

            } catch (error) {
                updateStatus(`エラー: ${error.message}`, true);
            } finally {
                document.getElementById('summarizeBtn').disabled = false;
            }
        }

        function downloadText(elementId, filePrefix) {
            const text = document.getElementById(elementId).value;
            if (!text) {
                alert("ダウンロードする内容がありません。");
                return;
            }

            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const timestamp = `${year}${month}${day}_${hours}${minutes}${seconds}`;

            const filename = `${filePrefix}_${timestamp}.txt`;

            const blob = new Blob([text], { type: "text/plain" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function updateStatus(msg, isProcessing) {
            const el = document.getElementById('status');
            el.innerText = msg;
            el.className = isProcessing ? '' : (msg.includes('エラー') ? 'error' : '');
            el.style.color = isProcessing ? '#4285f4' : (msg.includes('エラー') ? '#ea4335' : '#333');
        }

        function toggleButtons(isRecording) {
            document.getElementById('startBtn').disabled = isRecording;
            document.getElementById('stopBtn').disabled = !isRecording;
        }
    </script>
</body>
</html>
